
/ *! p5.sound.min.js v0.3.2 2016-11-01 * /

! function (t, e) {"function" == typeof define && define.amd? define ("p5.sound", ["p5"], função (t) {e (t)}: e ("objeto" = = tipo de exportação? requer ("../ p5"): t.p5)} (esta função (p5) {var sndcore; sndcore = função () {função "use strict";! (t, e, i) {function o (t) {t && (t.setTargetAtTime || (t.setTargetAtTime = t.setTargetValueAtTime))} return e = e || {}, window.hasOwnProperty ("webkitAudioContext") &&! window.hasOwnProperty ("AudioContext ") && (window.AudioContext = webkitAudioContext," function "! = typeof AudioContext.prototype.createGain && (AudioContext.prototype.createGain = AudioContext.prototype.createGainNode)," function "! = typeof AudioContext.prototype.createDelay && (AudioContext.prototype .createDelay = AudioContext.prototype.createDelayNode),"function"! = typeof AudioContext.prototype.createScriptProcessor && (AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode), "function"! = typeof AudioContext.prototype.createPeriodicWave && (AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable), AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain, AudioContext.prototype.createGain = function () {var t = this.internal_createGain (); return o (t.gain), t}, AudioContext.prototype.internal_createDelay = AudioContext. prototype.createDelay, AudioContext.prototype.createDelay = função (t) {var e = t? this.internal_createDelay (t): this.internal_createDelay (); return o (e.delayTime), e}, AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource, AudioContext.prototype.createBufferSource = function () {var t = this.internal_createBufferSource (); return t.start? (t.internal_start = t.start, t.start = função (e, i, o) {"undefined"! = typeof o? t.internal_start (e || 0, i, o): t.internal_start (e || 0, i || 0)}): t.start = função (t, e, i) {e || i? this .noteGrainOn (t || 0, e, i): this.noteOn (t || 0)}, t.stop? (t.internal_stop = t.stop, t.stop = função (e) {t.internal_stop ( e || 0)}): t.stop = função (t) {this.noteOff (t || 0)}, o (t.playbackRate), t}, AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor, AudioContext.prototype.createDynamicsCompressor = function () {var t = this.internal_createDynamicsCompressor (); return o (t.threshold), o (t.knee), o (t.ratio), o (t.reduction), o ( t.attack), o (t.release), t}, AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter, AudioContext.prototype.createBiquadFilter = function () {var t = this.internal_createBiquadFilter (); return o (t.frequency), o (t.detune), o (tQ), o (t.gain), t}, "function"! = typeof AudioContext.prototype.createOscillator && (AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator, AudioContext.prototype.createOscillator = function () {var t = this.internal_createOscillator (); retornar t.start? (t.internal_start = t. começar t.start = função (e) {t.internal_start (e || 0)}): t.start = função (t) {this.noteOn (t || 0)}, t.stop? (t. internal_stop = t.stop, t.stop = função (e) {t.internal_stop (e || 0)}): t.stop = função (t) {this.noteOff (t || 0)}, t.setPeriodicWave || (t.setPeriodicWave = t.setWaveTable), o (t.frequency), o (t.detune), t})), window.hasOwnProperty ("webkitOfflineAudioContext") &&! window.hasOwnProperty ("OfflineAudioContext") && (janela.OfflineAudioContext = webkitOfflineAudioContext), e} (janela); var t = new window.AudioContext; p5.prototype.getAudioContext = function () {return t}, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia; var e = document.createElement ("audio"); p5.prototype.isSupported = function () {return !! e.canPlayType}; var i = function () {return !! e.canPlayType && e. canPlayType ('audio / ogg; codecs = "vorbis"')}, o = function () {return !! e.canPlayType && e.canPlayType ("audio / mpeg;")}, n = function () {return !! e .canPlayType && e.canPlayType ('audio / wav; codecs = "1"')}, r = function () {return !! e.canPlayType && (e.canPlayType ("audio / x-m4a;") || e.canPlayType ("audio / aac;"))}, s = function () {return !! e.canPlayType && e.canPlayType ("audio / x-aiff;")}; p5.prototype.isFileSupported = função (t) {switch (t.toLowerCase ()) {case "mp3": return o (); caso "wav": return n (); caso "ogg": retornar i (); caso "mp4": retornar r (); caso "aiff": retornar s (); padrão: retornar! 1}}; var a = navigator.userAgent.match ( / (iPad | iPhone | iPod) / g) ?! ​​0:! 1; se (a) {var u =! 1, p = function () {if (! u) {var e = t.createBuffer (1, 1.22050), i = t.createBufferSource (); i.buffer = e, i.connect (t.destination), i.start (0), console.log ("start ios!"), "Running" = == t.state && (u =! 0)}}; document.addEventListener ("touchend", p,! 1), document.addEventListener ("touchstart", p,! 1)}} (); var master; master = function () {"use strict"; var t = function () {var t = p5.prototype.getAudioContext (); this.input = t.createGain (), this.output = t.createGain (), isto. limitador = t.createDynamicsCompressor (), this.limiter.threshold.value = 0, this.limiter.ratio.value = 20, this.audiocontext = t, this.output.disconnect (), this.inputSources = [], this.input.connect (this.output), this.meter = t.createGain (), this.fftMeter = t.createGain (), this.output.connect (this.meter), isto. output.connect (this.fftMeter), this.output.connect (this.audiocontext.destination), this.soundArray = [], this.parts = [], this.extensions = []}, e = new t; return p5.prototype.getMasterVolume = function () {return e.output.gain.value}, p5.prototype.masterVolume = função (t, i, o) {if ("number" == typeof t) {var i = i || 0, o = o || 0, n = e.audiocontext.currentTime, r = e.output.gain.value; e.output.gain.cancelScheduledValues ​​(n + o), e.output.gain.linearRampToValueAtTime ( r, n + o), e.output.gain.linearRampToValueAtTime (t, n + o + i)} else {if (! t) retorna e.output.gain; t.connect (e.output.ganho)}}, p5.prototype.soundOut = p5.soundOut = e, p5.soundOut._silentNode = e.audiocontext.createGain (), p5.soundOut._silentNode.gain.value = 0, p5.soundOut._silentNode.connect (e.audiocontext.destination), e} (sndcore); var helpers; helpers = function () {"use strict"; var t = master; p5.prototype.sampleRate = function () {return t.audiocontext.sampleRate} , p5.prototype.freqToMidi = função (t) {var e = Math.log (t / 440) /Math.log (2), i = Math.round (12 * e) +57; return i}, p5. prototype.midiToFreq = função (t) {return 440 * Math.pow (2, (t-69) / 12)}, p5.prototype.soundFormats = function () {t.extensions = []; para (var e = 0; e <arguments.length; e ++) {if (argumentos [e] = argumentos [e] .toLowerCase (),! (["Mp3", "wav", "ogg", "m4a", "aac"] .indexOf (argumentos [e])> - 1)) arremessar argumentos [e] + "não é um formato de som válido!"; t.extensions.push (argumentos [e])}}, p5.prototype.disposeSound = function () {for (var e = 0; e <t.soundArray.length; e ++) t.soundArray [e] .dispose ()}, p5.prototype.registerMethod ("remover", p5.protótipo .disposeSound), p5.prototype._checkFileFormats = função (e) {var i; if ("string" == typeof e) {i = e; var o = i.split ("."). pop (); se (["mp3", "wav", "ogg", "m4a", "aac"]. indexOf (o)> - 1) {var n = p5.prototype.isFileSupported (o); if (n) i = i; else for (var r = i.split ("."), s = r [r.length-1], a = 0; a <t.extensions.length; a ++) {var u = t.extensions [ a], n = p5.prototype.isFileSupported (u); if (n) {s = "", 2 === r.length && (s + = r [0]); para (var a = 1; a <= r.length-2; a ++) {var p = r [a]; s + = "." + p} i = s + = ".", i = i + = u; break}}} else for (var a = 0 ; a <t.extensions.length; a ++) {var u = t.extensions [a], n = p5.prototype.isFileSupported (u);se (n) {i = i + "." + u; break}}} else if ("object" == typeof e) for (var a = 0; a <e.length; a ++) {var u = e [ a] .split ("."). pop (), n = p5.prototype.isFileSupported (u); if (n) {i = e [a]; break}} return i}, p5.prototype._mathChain = função (t, e, i, o, n) {para (var r em t.mathOps) t.mathOps [r] instanceof n && (t.mathOps [r] .dispose (), i = r, i <t. mathOps.length-1 && (o = t.mathOps [r + 1])); retornar t.mathOps [i-1] .disconnect (), t.mathOps [i-1] .connect (e), e.connect (o), t.mathOps [i] = e, t}} (mestre); var errorHandler; errorHandler = function () {"use strict"; var t = function (t, e, i) {var o, n r = novo erro; r.name = t, r.originalStack = r.stack + e, o = r.stack + e, r.failedPath = i; var n = o.split ("\ n"); retorno n = n.filter (função (t) {return! t.match (/ (p5. | código nativo | globalInit) / g)}), r.stack = n.join ("\ n"), r}; return t} (); var panner; panner = function () {"use strict "; var t = master, e = t.audiocontext;" undefined "! = typeof e.createStereoPanner? (p5.Panner = function (t, i, o) {this.stereoPanner = this.input = e.createStereoPanner (), t.connect (this.stereoPanner), this.stereoPanner.connect (i)}, p5.Panner.prototype.pan = function (t, i) {var o = i || 0, n = e.currentTime + o; this.stereoPanner.pan.linearRampToValueAtTime (t, n)}, p5.Panner.prototype.inputChannels = função (t) {}, p5.Panner.prototype.connect = função (t) {this.stereoPanner.connect (t), p5.Panner.prototype.disconnect = function (t) {this.stereoPanner.disconnect ()}) :( p5.Panner = função (t, i, o) {this.input = e.createGain ( ), t.connect (this.input), this.left = e.createGain (), this.right = e.createGain (), this.left.channelInterpretation = "discrete", this.right.channelInterpretation = "discrete" , o> 1? (this.splitter = e.createChannelSplitter (2), this.input.connect (this.splitter), this.splitter.connect (this.left, 1), this.splitter.connect (this.right, 0)) :( this.input.connect (this.left), this.input.connect (this. direita)), this.output = e.createChannelMerger (2), this.left.connect (this.output, 0,1), this.right.connect (this.output, 0,0), this.output.connect (i)}, p5.Panner.prototype.pan = função (t, i) {var o = i || 0, n = e.currentTime + o, r = (t + 1) / 2, s = Matemática. cos (r * Math.PI / 2), a = Math.sin (r * Math.PI / 2); this.left.gain.linearRampToValueAtTime (a, n), this.right.gain.linearRampToValueAtTime (s, n )}, p5.Panner.prototype.inputChannels = function (t) {1 === t? (this.input.disconnect (), this.input.connect (this.left), this.input.connect (this. direito)): 2 === t && (this.splitter = e.createChannelSplitter (2), this.input.disconnect (), this.input.connect (this.splitter), this.splitter.connect (this.left, 1), this.splitter.connect (this.right, 0))}, p5.Panner.prototype.connect = function (t) {this.output.connect (t)}, p5.Panner.prototype.disconnect = function (t) {this.output.disconnect ()}), p5.Panner3D = função (t, i) {var o = e.createPanner (); return o.panningModel = "HRTF", o.distanceModel = "linear", o.setPosition (0,0,0), t.connect (o), o.connect (i ), o.pan = função (t, e, i) {o.setPosition (t, e, i)}, o}} (mestre); var soundfile; soundfile = function () {"use strict"; function t (t, e) {para (var i = {}, o = t.length, n = 0; o> n; n ++) {if (t [n]> e) {var r = t [n], s = novo p (r, n); i [n] = s, n + = 6e3} n ++} retornar i} função e (t) {para (var e = [], i = Object.keys (t) .sort ( ), o = 0; o <i.length; o ++) para (var n = 0; 10> n; n ++) {var r = t [i [o]], s = t [i [o + n]] ; se (r && s) {var a = r.sampleIndex, u = s.sampleIndex, p = ua; p> 0 && r.intervals.push (p); var c = e.some (função (t, e) {return t .interval === p? (t.count ++, t): void 0}); c || e.push ({intervalo: p, contagem:1})}} retornar e} função i (t, e) {var i = []; retornar t.forEach (função (t, o) {try {var r = Math.abs (60 / (t.interval / e)); r = n (r); var s = i.some (função (e) {return e.tempo === r? e.count + = t.count: void 0}), se (! s) {se (isNaN (r)) retornar; i.push ({tempo: Math.round (r), count: t.count})}} catch (a) {throw a}}), i} function o (t , e, i, o) {for (var r = [], s = Object.keys (t) .sort (), a = 0; a <s.length; a ++) para (var u = s [a] p = t [u], c = 0; c <p.intervals.length; c ++) {var h = Math.round (Math.abs (60 / (p.intervals [c] / i))); h = n (h); Math.abs (he) <o && r.push (p.sampleIndex / 44100)} return r = r.filter (função (t, e, i) {var o = i [e + 1] - t; return o> .01?! 0: void 0})} função n (t) {if (isFinite (t) && 0! = t) {para (; 90> t;) t * = 2; para (; t> = 180; = t; = t; = t; = t; = t; = t; = t; = t; "! = typeof t) {if (" string "== typeof t || "string" == typeof t [0]) {var n = p5.prototype._checkFileFormats (t); this.url = n} else if ("object" == typeof t &&! (janela. Arquivo && window.FileReader && window.FileList && window.Blob)) lançar "Não é possível carregar o arquivo porque a API do arquivo não é suportada"; t.file && (t = t.file), this.file = t} this._onended = function () {} , this._looping =! 1, this._playing =! 1, this._paused =! 1, this._pauseTime = 0, this._cues = [], this._lastPos = 0, this._counterNode, this._scopeNode, this .bufferSourceNodes = [], this.bufferSourceNode = null, this.buffer = null, this.playbackRate = 1, this.gain = 1, this.input = s.audiocontext.createGain (), this.output = s.audiocontext. createGain (), this.reversed =! 1, this.startTime = 0, this.endTime = null, this.pauseTime = 0, this.mode = "sustain", this.startMillis = null, this.panPosition = 0, this .panner = new p5.Panner (this.output, s.input, 2), (this.url || this.file) && this.load (e, i), s.soundArray.push (this), "function" == typeof o? this._whileLoading = o : this._whileLoading = function () {}}, p5.prototype.registerPreloadMethod ("loadSound", p5.prototype), p5.prototype.loadSound = função (t, e, i, o) {window.location.origin. indexOf ("file: //")> - 1 && "undefined" === window.cordova && alert ("Este esboço pode exigir que um servidor carregue arquivos externos. Consulte http://bit.ly/1qcInwS");var n = novo p5.SoundFile (t, e, i, o); return n}, p5.SoundFile.prototype.load = function (t, e) {var i = this, o = (new Error) .stack; if ( void 0! = this.url && ""! = this.url) {var n = new XMLHttpRequest; n.addEventListener ("progresso", função (t) {i._updateProgress (t)} ,! 1), n.open ("GET", this.url,! 0), n.responseType = "arraybuffer", n.onload = function () {if (200 == n.status) a.decodeAudioData (n.response, function (e) {i.buffer = e, i.panner.inputChannels (e.numberOfChannels), t && t (i)} , função (t) {var n = new r ("decodeAudioData", o, i.url), s = "Erro AudioContext em decodeAudioData para" + i.url; e? (n.msg = s, e (n) ): console.error (s + "\ n O rastreamento da pilha de erros inclui: \ n" + n.stack)}); else {var s = new r ("loadSound", o, i.url), u = "Unable para carregar "+ i.url +". O status da solicitação foi: "+ n.status +" ("+ n.statusText +") "; e? (s.message = u, e (s)): console.error (u + "\ n O rastreamento da pilha de erros inclui: \ n" + s.stack)}}, n.onerror = function (t) {var n = new r ("loadSound", o, i.url), s = "There não houve resposta do servidor em "+ i.url +". Verifique a conexão de url e internet. "; e? (n.message = s, e (n)): console.erro (s + "\ n O rastreamento da pilha de erros inclui: \ n" + n.stack)}, n.send ()} else if (void 0! = this.file) {var s = new FileReader, i = this; s.onload = function () {a.decodeAudioData (s.result, function (e) {i.buffer = e, i.panner.inputChannels (e.numberOfChannels), t && t (i)})}, s.onerror = função (t) {onerror && onerror (t)}, s.readAsArrayBuffer (this.file)}}, p5.SoundFile.prototype._updateProgress = função (t) {if (t.lengthComputable) {var e = t.loaded / t .total * .99; this._whileLoading (e, t)} else this._whileLoading ("tamanho desconhecido")}, p5.SoundFile.prototype.isLoaded = function () {return this.buffer?! 0:! 1} , p5.SoundFile.prototype.play = função (t, e, i, o, n) {var r, a, u = this, p = s.audiocontext.currentTime, t = t || 0; se (0> T && (t = 0), t + = p,! this.buffer) lançar "não está pronto para reproduzir o arquivo, o buffer ainda não foi carregado. Tente pré-carregar ()"; se (this._pauseTime = 0, "reiniciar"=== this.mode && this.buffer && this.bufferSourceNode) {var p = s.audiocontext.currentTime; this.bufferSourceNode.stop (t), this._counterNode.stop (t)} se (e && (this.playbackRate = e), this.bufferSourceNode = this._initSourceNode (), this._counterNode && (this._counterNode = void 0), this._counterNode = this._initCounterNode (), o) {if (! (o> = 0 && o <this.buffer.duration) ) lança "tempo de início fora do alcance"; r = o} else r = 0; n = n? n <= this.buffer.duration-r? n: this.buffer.duration: this.buffer.duration-r; var c = i || 1; this.bufferSourceNode.connect (this.output), this.output.gain.value = c, this._paused? (this.bufferSourceNode.start (t, this.pauseTime, n), isto ._counterNode.start (t, this.pauseTime, n)) :( this.bufferSourceNode.start (t, r, n), this._counterNode.start (t, r, n)), this._playing =! 0, this._paused =! 1, this.bufferSourceNodes.push (this.bufferSourceNode), isto.bufferSourceNode._arrayIndex = this.bufferSourceNodes.length-1; var h = function (t) {this._playing =! 1, this.removeEventListener ("ended", h,! 1), u._onended (u), u. () this.bufferSourceNode.onended = h, this.bufferSourceNode.loop = this._looping, this._counterNode.loop = this._looping, this._looping ===! 0) {var a = r + n; this.bufferSourceNode.loopStart = r, this.bufferSourceNode.loopEnd = a, this._counterNode.loopStart = r, this._counterNode.loopEnd = a}}, p5.SoundFile.prototype.playMode = função (t) {var e = t.toLowerCase () ; se ("reiniciar" === e && this.buffer && this.bufferSourceNode) para (var i = 0; i <this.bufferSourceNodes.length-1; i ++) {var o = s.audiocontext.currentTime; this.bufferSourceNodes [i] .stop (o)} se ("reinicie "! == e &&" sustain "! == e) throw'O modo de reprodução inválido. Deve ser" reiniciar "ou" sustentar "; this.mode = e}, p5.SoundFile.prototype.pause = function (t ) {var e = s.audiocontext.currentTime, t = t || 0, i = t + e; this.isPlaying () && this.buffer && this.bufferSourceNode? (this.pauseTime = this.currentTime (), this.bufferSourceNode. pare (i), this._counterNode.stop (i), this._paused =! 0, this._playing =! 1, this._pauseTime = this.currentTime ()): this._pauseTime = 0}, p5.SoundFile. prototype.loop = função (t, e, i, o, n) {this._looping =! 0, this.play (t, e, i, o, n)}, p5.SoundFile.prototype.setLoop = função ( t) {if (t ===! 0) this._looping =! 0; else {if (t! ==! 1) throw "Error: setLoop aceita true ou false"; this._looping =! 1} this .bufferSourceNode && (this.bufferSourceNode.loop = this._looping, this._counterNode.loop = this._looping)}, p5.SoundFile.prototype.isLooping = function () {return this.bufferSourceNode && this._looping ===! 0 && this.isPlaying () ===! 0?! 0:! 1}, p5.SoundFile.prototype.isPlaying = function () { devolva this._playing}, p5.SoundFile.prototype.isPaused = function () {return this._paused}, p5.SoundFile.prototype.stop = function (t) {var e = t || 0; if ("sustain" == this.mode) this.stopAll (e), this._playing =! 1, this.pauseTime = 0, this._paused =! 1; senão se (this.buffer && this.bufferSourceNode) {var i = s.audiocontext. currentTime, o = e || 0; this.pauseTime = 0, this.bufferSourceNode.stop (i + o), this._counterNode.stop (i + o), this._playing =! 1, this._paused =! 1 }}, p5.SoundFile.prototype.stopAll = função (t) {var e = s.audiocontext.currentTime, i = t || 0; if (this.buffer && this.bufferSourceNode) {for (var o = 0; o < this.bufferSourceNodes.length; o ++) if (void 0! = typeof this.bufferSourceNodes [o]) tente {this.bufferSourceNodes [o] .onended = function () {}, this.bufferSourceNodes [o] .stop (e + i)} catch (n) {} this._counterNode.stop (e + i), this._onended (this) }}, p5.SoundFile.prototype.setVolume = função (t, e, i) {if ("number" == typeof t) {var e = e || 0, i = i || 0, o = s. audiocontext.currentTime, n = this.output.gain.value; this.output.gain.cancelScheduledValues ​​(o + i), this.output.gain.linearRampToValueAtTime (n, o + i), this.output.gain.linearRampToValueAtTime ( t, o + i + e)} else {if (! t) retorna this.output.gain; t.connect (this.output.gain)}}, p5.SoundFile.prototype.amp = p5.SoundFile.prototype. setVolume, p5.SoundFile.prototype.fade = p5.SoundFile.prototype.setVolume, p5.SoundFile.prototype.getVolume = function () {return this.output.gain.value}, p5.SoundFile.prototype.pan = function ( t, e) {this.panPosition = t, this.panner.pan (t, e)}, p5.SoundFile.prototype.getPan = function () {return this.panPosition}, p5.SoundFile.prototype.rate = function (t) {if (this.playbackRate! == t ||! this.bufferSourceNode || this.bufferSourceNode.playbackRate.value! == t) {this.playbackRate = t; var e = t; se (0 === this.playbackRate && this._playing && this.pause (), this.playbackRate <0 &&! this.reversed) {var i = this.currentTime (); this.bufferSourceNode.playbackRate.value; this.reverseBuffer (), e = Math.abs (t); var o = (i-this.duration ()) / e; this.pauseTime = o} else this.playbackRate> 0 && this.reversed && this.reverseBuffer (); se (this.bufferSourceNode) { var n = s.audiocontext.currentTime; this.bufferSourceNode.playbackRate.cancelScheduledValues ​​(n), this.bufferSourceNode.playbackRate.linearRampToValueAtTime (Math.abs (e), n), this._counterNode.playbackRate.cancelScheduledValues ​​(n), isto ._counterNode.playbackRate.linearRampToValueAtTime (Math.abs (e), n)}}}, p5.SoundFile.prototype.setPitch = função (t) {var e = midiToFreq (t) / midiToFreq (60); this.rate (e)}, p5.SoundFile.prototype.getPlaybackRate = função () {retorna this.playbackRate}, p5.SoundFile. prototype.duration = function () {return this.buffer? this.buffer.duration: 0}, p5.SoundFile.prototype.currentTime = function () {return this._pauseTime> 0? this._pauseTime: this._lastPos / a .sampleRate}, p5.SoundFile.prototype.jump = function (t, e) {if (0> t || t> this.buffer.duration) lançar "tempo de salto fora do alcance", se (e> this.buffer .duration-t) throw "end time out of range"; var i = t || 0, o = e || this.buffer.duration-t; this.isPlaying () && this.stop (), this.play ( 0, this.playbackRate, this.output.gain.value, i, o)}, p5.SoundFile.prototype.channels = function () {return this.buffer.numberOfChannels}, p5.SoundFile.prototype.sampleRate = function ( ) {return this.buffer.sampleRate}, p5.prodote.frames = function () {return this.buffer.length}, p5.SoundFile.prototype.getPeaks = função (t) {if (! this.buffer) throw "Não é possível carregar picos ainda, o buffer não está carregado", se (t || (t = 5 * window.width), this.buffer) {for (var e = this.buffer, i = e.length / t, o = ~~ (i / 10) || 1, n = e .numberOfChannels, r = novo Float32Array (Math.round (t)), s = 0; n> s; s ++) para (var a = e.getChannelData (s), u = 0; t> u; u ++) {for (var p = ~~ (u * i), c = ~~ (p + i), h = 0, l = p; c> l; l + = o) {var f = a [l]; f> h ? h = f: -f> h && (h = f)} (0 === s || Math.abs (h)> r [u]) && (r [u] = h)} return r}}, p5.SoundFile.prototype.reverseBuffer = function () {var t = this.getVolume (); se (this.setVolume (0, .01,0), this.pause () ,! this.buffer) lançar "SoundFile is não é feito carregar "; para (var e = 0; e <this.buffer.numberOfChannels; e ++) Array.prototype.reverse.call (this.buffer.getChannelData (e)); this.reversed =! this.reversed, this .setVolume (t, .01, .0101),this.play ()}, p5.SoundFile.prototype.onended = function (t) {return this._onended = t, this}, p5.SoundFile.prototype.add = function () {}, p5.SoundFile.prototype. dispos = function () {var t = s.audiocontext.currentTime, e = s.soundArray.indexOf (this); se (s.soundArray.splice (e, 1), this.stop (t), this.buffer && this. bufferSourceNode) {for (var i = 0; i <this.bufferSourceNodes.length-1; i ++) if (null! == this.bufferSourceNodes [i]) {this.bufferSourceNodes [i] .disconnect (); tente {this .bufferSourceNodes [i] .stop (t)} catch (o) {} this.bufferSourceNodes [i] = null} if (this.isPlaying ()) {try {this._counterNode.stop (t)} catch (o) {console.log (o)} this._counterNode = null}} this.output && (this.output.disconnect (), this.output = null), this.panner && (this.panner.disconnect (), this.panner = null)}, p5.SoundFile.prototype.connect = function (t) {t? t.hasOwnProperty ("input")? this.panner.connect (t.entrada): this.panner.connect (t): this.panner.connect (s.input)}, p5.SoundFile.prototype.disconnect = function () {this.panner.disconnect ()}, p5.Programa de arquivoSoundFile. .getLevel = function (t) {console.warn ("p5.SoundFile.getLevel foi removido da biblioteca. Use p5.Amplitude em vez disso"), p5.SoundFile.prototype.setPath = function (t, e) {var i = p5.prototype._checkFileFormats (t); this.url = i, this.load (e)}, p5.SoundFile.prototype.setBuffer = função (t) {var e = t.length, i = t [0 ] .length, o = a.createBuffer (e, i, a.sampleRate) ;! t [0] instanceof Float32Array && (t [0] = new Float32Array (t [0])) para (var n = 0; e > n; n ++) {var r = o.getChannelData (n); r.set (t [n])} this.buffer = o, this.panner.inputChannels (e)}, p5.SoundFile.prototype._initCounterNode = function () {var t = this, e = a.currentTime, i = a.createBufferSource (); retorna t._scopeNode && (t._cope.Node.disconnect (), t._scopeNode.onaudioprocess = void 0, t._scopeNode = null), t._scopeNode = a.createScriptProcessor (256,1,1), i.buffer = u (t.buffer), i.playbackRate.setValueAtTime (t.playbackRate, e) , i.connect (t._scopeNode), t._scopeNode.connect (p5.soundOut._silentNode), t._scopeNode.onaudioprocess = função (e) {var i = e.inputBuffer.getChannelData (0); t._lastPos = i [i.length-1] || 0, t._onTimeUpdate (t._lastPos)}, i}, p5.SoundFile.prototype._initSourceNode = function () {var t = this, e = (a.currentTime, a .createBufferSource ()); return e.buffer = t.buffer, e.playbackRate.value = t.playbackRate, e}; var u = function (t) {for (var e = new Float32Array (t.length), i = a.createBuffer (1, t.length, 44100), o = 0; o <t.length; o ++) e [o] = o; return i.getChannelData (0) .set (e), i}; p5 .SoundFile.prototype.processPeaks = function (n, r, s, a) {var u = this.buffer.length, p = this.buffer.sampleRate, h = this.buffer, l = r || .9, f = l, d = s || .22, m = a || 200,y = novo OfflineAudioContext (1, u, p), v = y.createBufferSource (); v.buffer = h; var g = y.createBiquadFilter (); g.type = "lowpass", v.connect (g), g.connect (y.destination), v.start (0), y.startRendering (), y.complete = function (r) {var s = r.renderedBuffer, a = s.getChannelData (0); do c = t (a, f), f - =. 005; while (Object.keys (c) .length <m && f> = d); var u = e (c), p = i (u, s.sampleRate), h = p.sort (função (t, e) {return e.count-t.count}). splice (0,5); this.tempo = h [0] .tempo; var l = 5, y = o ( c, h [0] .tempo, s.sampleRate, l); n (y)}}; var p = função (t, e) {this.sampleIndex = e, this.amplitude = t, this.tempos = [ ] this.intervals = []}, c = []; p5.SoundFile.prototype.addCue = função (t, e, i) {var o = this._cueIDCounter ++, n = new h (e, t, o, i); return this._cues.push (n), o}, p5.SoundFile.prototype.removeCue = função (t) {for (var e = this._cues.length, i = 0; e> i; i ++) {var o = this._cues [i]; o.id === t && this.cues.splice (i,1)} 0 === this._cues.length}, p5.SoundFile.prototype.clearCues = function () {this._cues = []}, p5.SoundFile.prototype._onTimeUpdate = function (t) {for (var e = t / this.buffer.sampleRate, i = this._cues.length, o = 0; i> o; o ++) {var n = this._cues [o], r = n.time, s = n.val ; this._prevTime <r && e> = r && n.callback (s)} this._prevTime = e}; var h = função (t, e, i, o) {this.callback = t, this.time = e, this. id = i, this.val = o}} (sndcore, errorHandler, master); var amplitude; amplitude = function () {"use strict"; var t = master; p5.Amplitude = function (e) {this.bufferSize = 2048, this.audiocontext = t.audiocontext, this.processor = this.audiocontext.createScriptProcessor (this.bufferSize, 2,1), this.input = this.processor, this.output = this.audiocontext.createGain (), this.mermo = e || 0, this.volume = 0, this.average = 0, this.stereoVol = [0,0], this.stereoAvg = [0,0], this.stereoVolNorm = [0,0] , this.volMax = .001, isto.normalize =! 1, this.processor.onaudioprocess = this._audioProcess.bind (this), this.processor.connect (this.output), this.output.gain.value = 0, this.output.connect (this.audiocontext .destination), t.meter.connect (this.processor), t.soundArray.push (this)}, p5.Amplitude.prototype.setInput = function (e, i) {t.meter.disconnect (), i && ( this.smoothing = i), null == e? (console.log ("A fonte de entrada de amplitude não está pronta! Conectando à saída mestre em vez disso"), t.meter.connect (this.processor)): e instanceof p5.Signal ? e.output.connect (this.processor): e? (e.connect (this.processor), this.processor.disconnect (), this.processor.connect (this.output)): t.meter.connect ( this.processor)}, p5.Amplitude.prototype.connect = function (e) {e? e.hasOwnProperty ("input")? this.output.connect (e.input): this.output.connect (e): this.output.connect (this.panner.connect (t.input))}, p5.Amplitude.prototype.disconnect = function (t) {this.output.disconnect ()}, p5.Amplitude.prototype._audioProcess = function (t) {for (var e = 0; e <t.inputBuffer.numberOfChannels; e ++) {for (var i, o = t.inputBuffer.getChannelData (e), n = o.length, r = 0, s = 0, a = 0; n> a; a ++) i = o [a], this.normalize? (r + = Math.max (Math.min (i / this.volMax, 1), - 1), s + = Math.max (Math.min (i / this.volMax, 1), - 1) * Math.max (Math.min (i / this.volMax, 1), - 1)): (r + = i, s + = i * i); var u = r / n, p = Math.sqrt (s / n); .stereoVol [e] = Math.max (p, this.stereoVol [e] * this.smoothing), this.stereoAvg [e] = Math.max (u, this.stereoVol [e] * this.smoothing), isto .volMax = Math.max (this.stereoVol [e], this.volMax)} var c = this, h = this.stereoVol.reduce (função (t, e, i) {retorna c.stereoVolNorm [i-1] = Math.max (Math.min (c.stereoVol [i-1] /c.volMax,1), 0), c.stereoVolNorm [i] = Math.max (Math.min (c.stereoVol [i] / c.volMax, 1), 0), t + e}); this.volume = h / this.stereoVol.length, isto.volNorm = Math.max (Math.min (this.volume / this.volMax, 1), 0)}, p5.Amplitude.prototype.getLevel = função (t) {return "undefined"! = typeof t? this.normalize ? this.stereoVolNorm [t]: this.stereoVol [t]: this.normalize? this.volNorm: this.volume}, p5.Amplitude.prototype.toggleNormalize = function (t) {"boolean" == typeof t? this .normalize = t: this.normalize =! this.normalize}, p5.Amplitude.prototype.smooth = function (t) {t> = 0 && 1> t? this.smoothing = t: console.log ("Erro: o liso deve estar entre 0 e 1 ")}, p5.Amplitude.prototype.dispose = function () {var e = t.soundArray.indexOf (this); t.soundArray.splice (e, 1), this.input.disconnect ( ), this.output.disconnect (), this.input = this.processor = void 0, this.output = void 0}} (mestre); var fft; fft = function () {"use strict"; var t = mestre p5.FFT = função (e, i) {this.smoothing = e || .8, this.bins = i || 1024;var o = 2 * i || 2048; this.input = this.analyser = t.audiocontext.createAnalyser (), t.fftMeter.connect (this.analyser), this.analyser.smoothingTimeConstant = this.smoothing, this.analyser .fftSize = o, this.freqDomain = new Uint8Array (this.analyser.frequencyBinCount), this.timeDomain = new Uint8Array (this.analyser.frequencyBinCount), this.bass = [20,140], this.lowMid = [140,400], isto .mid = [400,2600], this.highMid = [2600,5200], this.treble = [5200,14e3], t.soundArray.push (this)}, p5.FT.prototype.setInput = function (e ) {e? (e.output? e.output.connect (this.analyser): e.connect && e.connect (this.analyser), t.fftMeter.disconnect ()): t.fftMeter.connect (this.analyser) } p5.FT.prototype.waveform = function () {for (var t, e, i, r = 0; r <arguments.length; r ++) "number" == typeof arguments [r] && (t = argumentos) [r], this.analyser.fftSize = 2 * t), "string" == typeof arguments [r] &&(e = argumentos [r]); se (e &&! p5.prototype._isSafari ()) retornar o (this, this.timeDomain), this.analyser.getFloatTimeDomainData (this.timeDomain), this.timeDomain; n (isto, this.timeyser.getByteTimeDomainData (this.timeDomain); for (var i = new Array, r = 0; r <this.timeDomain.length; r ++) {var s = p5.prototype.map (isto. timeDomain [r], 0,255, -1,1); i.push (s)} return i}, p5.FT.prototype.analyze = function () {for (var t, o, n = 0; n <argumentos .length; n ++) "number" == typeof arguments [n] && (t = this.bins = arguments [n], this.analyser.fftSize = 2 * this.bins), "string" == typeof arguments [n ] && (o = arguments [n]); se (o && "db" === o.toLowerCase ()) retornar e (this), this.analyser.getFloatFrequencyData (this.freqDomain), this.freqDomain; i (este , this.freqDomain), this.analyser.getByteFrequencyData (this.freqDomain); var r = Array.apply ([], isto.freqDomain); return r.length === this.analyser.fftSize, r.constructor === Array, r}, p5.FT.prototype.getEnergy = função (e, i) {var o = t.audiocontext.sampleRate /2;if("bass"=== e e th th th , i = this.lowMid [1]): "mid" === e? (e = this.mid [0], i = this.mid [1]): "highMid" === e? (e = this.highMid [0], i = this.highMid [1]): "treble" === e && (e = this.treble [0], i = this.treble [1]), "number"! = typeof e) lançar "entrada inválida para getEnergy ()"; se (i) {if (e && i) {if (e> i) {var n = i; i = e, e = n} para (var r = Math.round (e / o * this.freqDomain.length), s = Math.round (i / o * this.freqDomain.length), a = 0, u = 0, p = r; s> = p; p ++) a + = this.freqDomain [p], u + = 1; var c = a / u; return c} throw "entrada inválida para getEnergy ()"} var h = Math.round (e / o * this.freqDomain.length); return this.freqDomain [h]}, p5.FT.prototype.getFreq = function (t, e) {console.log ("getFreq () está obsoleta. Por favor use getEnergy () em vez disso."); var i = this.getEnergy (t, e); return i}, p5. FFT.prototype.getCentroid = function () {for (var e = t.audiocontext.sampleRate / 2, i = 0, o = 0, n = 0; n <this.freqDomain.length; n ++) i + = n * this .freqDomain [n], o + = this.freqDomain [n]; var r = 0; 0! = o && (r = i / o); var s = r * (e / this.freqDomain.length); return s} , p5.FT.prototype.smooth = function (t) {t && (this.smoothing = t), this.analyser.smoothingTimeConstant = t}, p5.FT.prototype.dispose = function () {var e = t.soundArray .indexOf (this); t.soundArray.splice (e, 1), this.analyser.disconnect (), this.analyser = void 0}, p5.FT.prototype.linAmands = function (t) {for (var t = t || 16, e = this.freqDomain, i = e.length, o = Math.floor (i / t), n = new Array (t), r = 0, s = 0; i> s; s ++ ) n [r] = void 0! == n [r]? (n [r] + e [s]) / 2: e [s], s% o == o-1 && r ++; return n}, p5. FFT.prototype.logMedidas = função (e) {for (var i = t.audiocontext.sampleRate / 2, o = this.freqDomain, n = o.length, r = nova matriz (e.length), s = 0, a = 0; n> a; a ++) {var u = Math.round (a * i / this.freqDomain.length); u> e [s] .hi && s ++, r [s] = void 0! == r [s] ? (r [s] + o [a]) / 2: o [a]} return r}, p5.FT.prototype.getOctaveBands = função (e, i) {var e = e || 3, i = i || 15.625, o = [], n = {lo: i / Math.pow (2,1 / (2 * e)), ctr: i, hi: i * Math.pow (2,1 / (2 * e))}; o.push (n); para (var r = t.audiocontext.sampleRate / 2; n.hi <r;) {var s = {}; s.lo = n.hi, s.ctr = n.ctr * Math.pow (2,1 / e), s.hi = s.ctr * Math.pow (2,1 / (2 * e)), o.push (s), n = s} return o}; var e = function (t) {t.freqDomain instanceof Float32Array ==! 1 && (t.freqDomain = new Float32Array (t.analyser.frequencyBinCount))}, i = função (t) {t.freqDomain instanceof Uint8Array ==! 1 && (t.freqDomain = novo Uint8Array (t.analyser.frequencyBinCount))}, o = função (t) {t.timeDomain instanceof Float32Array ==! 1 && (t.timeDomain = new Float32Array (t.analyser.frequencyBinCount))}, n = função (t) {t.timeDomain instanceof Uint8Array ==! 1 && (t.timeDomain = new Uint8Array (t. analisador.frequencyBinCount))}} (mestre); var Tone_core_Tone; Tone_core_Tone = function () {"use strict"; função t (t) {return void 0 === t} função e (t) {return "function" = = typeof t} var i; if (t (window.AudioContext) && (window.AudioContext = window.webkitAudioContext), t (window.OfflineAudioContext) && (window.OfflineAudioContext = window.webkitOfflineAudioContext), t (AudioContext)) lançar novo Erro ("Web Audio não é suportado neste navegador"); i = new AudioContext, e (AudioContext.prototype.createGain) || (AudioContext.prototype.createGain = AudioContext.prototype.createGainNode), e (AudioContext.prototype.createDelay) ) || (AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode), e (AudioContext.prototype.createPeriodicWave) || (AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable), e (AudioBufferSourceNode.prototype.start) || (AudioBufferSourceNode.prototype. start = AudioBufferSourceNode.prototype.noteGrainOn), e (AudioBufferSourceNode.prototype.stop) || (AudioBufferSourceNode.prototype.stop = AudioBufferSourceNode.prototype.noteOff),protótipo.noteOff),protótipo.noteOff),
(OscillatorNode.prototype.start) || OscillatorNode.prototype.setPeriodicWave) || (OscillatorNode.prototype.setPeriodicWave = OscillatorNode.prototype.setWaveTable), AudioNode.prototype._nativeConnect = AudioNode.prototype.connect, AudioNode.prototype.connect = function (e, i, o) {if (e.input) Array.isArray (e.input)? (t (o) && (o = 0), this.connect (e.input [o])): this.connect (e.input, i, o ); senão tente {e instanceof AudioNode? this._nativeConnect (e, i, o): this._nativeConnect (e, i)} catch (n) {throw new Error ("erro ao conectar-se ao nó:" + e)}} ; var o = function (e, i) {t (e) || 1 === e? this.input = this.context.createGain (): e> 1 && (this.input = new Array (e)), t (i) || 1 === i? this.output = this.context.createGain (): i>1 && (this.output = new Array (e))}; o.prototype.set = function (e, i, n) {if (this.isObject (e)) n = i; else if (this.isString (e )) {var r = {}; r [e] = i, e = r} para (var s in e) {i = e [s]; var a = this; if (-1! == s.indexOf (".")) {for (var u = s.split ("."), p = 0; p <u.length-1; p ++) a = a [u [p]]; s = u [u .length-1]} var c = a [s]; t (c) || ​​(o.Signal && c instanceof o.Signal || o.Param && c instanceof o.Param? c.value! == i && (t (n) ? c.value = i: c.rampTo (i, n)): c instanceof AudioParam? c.value! == i && (c.value = i): c instanceof o? c.set (i): c! = = i && (a [s] = i))} return this}, o.prototype.get = function (i) {t (i)? i = this._collectDefaults (this.constructor): this.isString (i) && (i = [i]); para (var n = {}, r = 0; r <i.length; r ++) {var s = i [r], a = this, u = n; if (-1! == s.indexOf (".")) {for (var p = s.split ("."), c = 0; c <p.length-1; c ++) {var h = p [c]; u [h] = u [h] || {}, u = u [h],a = a [h]} s = p [p.length-1]} var l = a [s]; this.isObject (i [s])? u [s] = l.get (): o.Signal && l instance of o.Signal? u [s] = l.value: o.Param && l instanceof o.Param? u [s] = l.value: l instanceof AudioParam? u [s] = l.value: l instanceof o? u [ s] = l.get (): e (l) || t (l) || (u [s] = l)} return n}, o.prototype._collectDefaults = função (e) {var i = [] ; if (t (e.defaults) || (i = Object.keys (e.defaults)) ,! t (e._super)) para (var o = this._collectDefaults (e._super), n = 0; n <o.length; n ++) - 1 === i.indexOf (o [n]) && i.push (o [n]); return i}, o.prototype.toString = function () {for (var t em o) {var i = t [0] .match (/ ^ [AZ] $ /), n = o [t] === this.constructor; se (e (o [t]) && i && n) retornar t} retornar "Tom"}, o.context = i, o.prototype.context = o.context, o.prototype.bufferSize = 2048, o.prototype.blockTime = 128 / o.context.sampleRate, o.prototype.dispose = function () {return this.isUndef (this.input) || (isto.instância de entrada de AudioNode && this.input.disconnect (), this.input = null), this.isUndef (this.output) || (this.output instanceof AudioNode && this.output.disconnect (), this.output = null), this}; var n = null; o.prototype.noGC = function () {return this.output.connect (n), this}, AudioNode.prototype.noGC = function () {return this.connect (n), this}, o .prototype.connect = function (t, e, i) {return Array.isArray (this.output)? (e = this.defaultArg (e, 0), this.output [e] .connect (t, 0, i )): this.output.connect (t, e, i), this}, o.prototype.disconnect = function (t) {return Array.isArray (this.output)? (t = this.defaultArg (t, 0 ), this.output [t] .disconnect ()): this.output.disconnect (), this}, o.prototype.connectSeries = function () {if (arguments.length> 1) para (var t = arguments [ 0], e = 1; e <arguments.length; e ++) {var i = arguments [e]; t.connect (i), t = i} retorna isso}, o.prototype.connectParallel = function () {var t = arguments [0]; if (arguments.length> 1) para (var e = 1; e <arguments.length; e ++) {var i = arguments [e]; t.connect ( i)} return this}, o.prototype.chain = function () {if (arguments.length> 0) para (var t = this, e = 0; e <arguments.length; e ++) {var i = arguments [ e]; t.connect (i), t = i} retorna isso}, o.prototype.fan = function () {if (arguments.length> 0) para (var t = 0; t <arguments.length; t ++ ) this.connect (argumentos [t]); retorna isso}, AudioNode.prototype.chain = o.prototype.chain, AudioNode.prototype.fan = o.prototype.fan, o.prototype.defaultArg = function (e, i ) {if (this.isObject (e) && this.isObject (i)) {var o = {}; para (var n em e) o [n] = this.defaultArg (i [n], e [n]) ; for (var r in i) o [r] = this.defaultArg (e [r], i [r]); return o} return t (e)? i: e}, o.prototype.optionsObject = função ( t, e, i) {var o = {}; if (1 === t.length && this.isObject (t [0])) o = t [0]; else for (var n = 0; n <e.length; n ++) o [e [n]] = t [n]; retorna this.isUndef (i)? o: this.defaultArg (o, i)}, o.prototype.isUndef = t, o.prototype.isFunction = e, o.prototype.isNumber = função (t) {return "number" == typeof t}, o.prototype.isObject = função (t) {return "[object Object]" === Object.prototype.toString .call (t) && t.constructor === Objeto}, o.prototype.isBoolean = função (t) {return "boolean" == typeof t}, o.prototype.isArray = função (t) {retorna Array.isArray (t)}, o.prototype.isString = função (t) {return "string" == typeof t}, o.noOp = function () {}, o.prototype._readOnly = função (t) {if (Array .isArray (t)) para (var e = 0; e <t.length; e ++) this._readOnly (t [e]); else Object.defineProperty (isto, t, {writable:! 1, enumerable:! 0 })}, o.prototype._writable = function (t) {if (Array.isArray (t)) para (var e = 0; e <t.length; e ++) this._writable (t [e]); senão Object.defineProperty (this, t, {writable :!0})}, o.State = {Iniciado: "started", Stopped: "stopped", Paused: "paused"}, o.prototype.equalPowerScale = função (t) {var e = .5 * Math.PI; retornar Math.sin (t * e)}, o.prototype.dbToGain = função (t) {return Math.pow (2, t / 6)}, o.prototype.gainToDb = função (t) {return 20 * ( Math.log (t) /Math.LN10)}, o.prototype.now = function () {return this.context.currentTime}, o.extend = function (e, i) {function n () {} t ( i) && (i = o), n.prototype = i.prototype, e.prototype = new n, e.prototype.constructor = e, e._super = i}; var r = []; return o._initAudioContext = função (t) {t (o.context), r.push (t)}, o.setContext = função (t) {o.prototype.context = t, o.context = t; para (var e = 0; e <r.length; e ++) r [e] (t)}, o.startMobile = function () {var t = o.context.createOscillator (), e = o.context.createGain (); why. valor = 0, t.connect (e), e.connect (o.context.destination); var i = o.context.currentTime; t.start (i), t.stop (i + 1)}, o._initAudioContext (função (t) {o.prototype.blockTime = 128 / t.sampleRate, n = t.createGain (), n.gain.value = 0, n.connect (t .destination)}), o.version = "r7-dev", o} (); var Tone_signal_SignalBase; Tone_signal_SignalBase = função (t) {"use strict"; return t.SignalBase = function () {}, t.extend (t.SignalBase), t.SignalBase.prototype.connect = function (e, i, o) {return t.Signal && t.Signal === e.constructor || t.Param && t.Param === e.constructor || t.TimelineSignal && t.TimelineSignal === e.constructor? (e._param.cancelScheduledValues ​​(0), e._param.value = 0, e.overridden =! 0): e instanceof AudioParam && (e.cancelScheduledValues ​​(0), e .value = 0), t.prototype.connect.call (this, e, i, o), this}, t.SignalBase} (Tone_core_Tone); var Tone_signal_WaveShaper; Tone_signal_WaveShaper = função (t) {"use strict"; return t.WaveShaper = função (t, e) {this._shaper = this.input = this.output = this.context.createWaveShaper (), this._curve = null, Array.isArray (t)? this.curve = t: isFinite (t) || this.isUndef (t)? this._curve = new Float32Array (this.defaultArg (t, 1024)): this.isFunction (t) && (this._curve = new Float32Array (this.defaultArg (e, 1024)), this.setMap (t))} , t.extend (t.WaveShaper, t.SignalBase), t.WaveShaper.prototype.setMap = function (t) {for (var e = 0, i = this._curve.length; i> e; e ++) {var o = e / i * 2-1; this._curve [e] = t (o, e)} retorna this._shaper.curve = this._curve, this}, Object.defineProperty (t.WaveShaper.prototype, "curva "{{{{{{{{{{{{{{{{{{{ (t.WaveShaper.prototype, "oversample", {get: function () {return this._shaper.oversample}, set: function (t) {if (-1 === ["none", "2x","4x"]. IndexOf (t)) throw new Error ("oversampling inválido:" + t); this._shaper.oversample = t}}), t.WaveShaper.prototype.dispose = function () {return t.prototype .dispose.call (this), this._shaper.disconnect (), this._shaper = null, this._curve = null, this}, t.WaveShaper} (Tone_core_Tone); var Tone_core_Type; Tone_core_Type = função (Tone) {" use a função "estrita" getTransportBpm () {return Tone.Transport && Tone.Transport.bpm? Tone.Transport.bpm.value: 120} função getTransportTimeSignature () {return Tone.Transport && Tone.Transport.timeSignature? Tone.Transport.timeSignature: 4} function toNotationHelper (t, e, i, o) {for (var n = this.toSeconds (t), r = this.notationToSeconds (o [o.length-1], e, i), s = "", a = 0; a <o.length; a ++) {var u = this.notationToSeconds (o [a], e, i), p = n / u, c = 1e-6; if (c> 1-p% 1 && (p + = c), p = Math.floor (p), p>0) {if (s + = 1 === p? O [a]: p.toString () + "*" + o [a], n- = p * u, r> n) break; s + = "+ "}} return" "=== s && (s =" 0 "), s} Tone.Type = {Padrão:" number ", Time:" time ", Frequência:" frequency ", NormalRange:" normalRange ", AudioRange : "audioRange", Decibels: "db", Intervalo: "intervalo", BPM: "bpm", Positivo: "positivo", Cents: "cents", Graus: "degrees", MIDI: "midi", TransportTime: " TransportTime ", Ticks:" tick ", Nota:" nota ", Milisegundos:" milissegundos ", Notação:" notação "}, Tone.prototype.isNowRelative = function () {var t = new RegExp (/ ^ \ s * \ + (.) + / i); função de retorno (e) {return t.test (e)}} (), Tone.prototype.isTicks = function () {var t = new RegExp (/ ^ \ d + i $ / i); função de retorno (e) {return t.test (e)}} (), Tone.prototype.isNotation = function () {var t = new RegExp (/ ^ [0-9] + [mnt] $ / i); função de retorno (e) {return t.test (e)}} (), Tone. prototype.isTransportTime = function () {var t = new RegExp (/ ^ (\ d + (\. \ d +)? \:) {1,2} (\ d + (\. \ d +)?)? $ / i) ; função de retorno (e) {return t.test (e)}} (), Tone.prototype.isNote = function () {var t = new RegExp (/ ^ [ag] {1} (b | # | x | bb)? -? [0-9] + $ / i); função de retorno (e) {return t.test (e)}} (), Tone.prototype.isFrequency = function () {var t = new RegExp ( /^\*********************************************************************************************************************** () e = this.defaultArg (e, getTransportBpm ()), i = this.defaultArg (i, getTransportTimeSignature ()); var o = 60 / e; "1n" === t && (t = "1m"); var n = parseInt (t, 10), r = 0; 0 === n && (r = 0); var s = t.slice (-1); return r = "t" === s? 4 / n * 2 /3:"n"===s?4/n:"m"==s?n*i:0,o*r},Tone.prototype.transportTimeToSeconds = função (t, e, i) {e = this.defaultArg (e, getTransportBpm ()), i = this.defaultArg (i, getTransportTimeSignature ()); var o = 0, n = 0, r = 0, s = t.split (":"); 2 === s.length? (o = parseFloat (s [0]), n = parseFloat (s [1])): 1 === s.length? n = parseFloat (s [0]): 3 === s.length && (o = parseFloat (s [0]), n = parseFloat (s [1]), r = parseFloat (s [2])); var a = o * i + n + r / 4; retorna a * (60 / e)}, Tone.prototype.ticksToSeconds = função (t, e) {if (this.isUndef (Tone.Transport)) retorna 0; t = ParseFloat (t), e = this.defaultArg (e, getTransportBpm ()); var i = 60 / e / Tone.Transport.PPQ; return i * t}, Tone.prototype.frequencyToSeconds = função (t) {return 1 /parseFloat(t)},Tone.prototype.samplesToSeconds=function(t){return t / this.context.sampleRate}, Tone.prototype.secondsToSamples = function (t) {return t * this.context.sampleRate}, Tone .prototype.secondsToTransportTime = function (t, e, i) {e = this.defaultArg (e,getTransportBpm ()), i = this.defaultArg (i, getTransportTimeSignature ()); var o = 60 / e, n = t / o, r = Math.floor (n / i), s = n% 1 * 4; n = Math.floor (n)% i; var a = [r, n, s]; return a.join (":")}, Tone.prototype.secondsToFrequency = função (t) {return 1 / t}, Tone.prototype.toTransportTime = função (t, e, i) {var o = this.toSeconds (t); retorna this.secondsToTransportTime (o, e, i)}, Tone.prototype.toFrequency = function (t, e) {return this.isFrequency (t)? parseFloat (t): this.isNotation (t) || this.isTransportTime (t)? this.secondsToFrequency (this.toSeconds (t, e)): this.isNote (t)? this.noteToFrequency (t): t}, Tone.prototype.toTicks = function (t) {if (this.isUndef (Tone.Transport)) retorna 0; var e = Tone.Transport.bpm.value, i = 0; se (this.isNowRelative (t)) t = t.replace ("+", ""), i = Tone.Transport.ticks; else if (this.isUndef (t)) retorna Tone.Transport.ticks; var o = this.toSeconds (t), n = 60 / e, r = o / n, s = r * Tom.Transport.PPQ; return Math.round (s + i)}, Tone.prototype.toSamples = função (t) {var e = this.toSeconds (t); return Math.round (e * this.context.sampleRate)} , Tone.prototype.toSeconds = function (time, now) {if (now = this.defaultArg (now, this.now ()), this.isNumber (time)) return time; if (this.isString (time)) {var plusTime = 0; this.isNowRelative (time) && (time = time.replace ("+", ""), plusTime = now); var betweenParens = time.match (/ \ (([^) (] + ) \) / g); se (betweenParens) for (var j = 0; j <betweenParens.length; j ++) {var symbol = betweenParens [j] .replace (/ [\ (\)] / g, "") , symbolVal = this.toSeconds (symbol); time = time.replace (betweenParens [j], symbolVal)} if (-1! == time.indexOf ("@")) {var quantizationSplit = time.split ("@ "), se (this.isUndef (Tone.Transport)) lança um novo erro (" quantization requires Tone.Transport "); var toQuantize = quantizationSplit [0].trim (); "=== toQuantize && (toQuantize = void 0), plusTime> 0 && (toQuantize =" + "+ toQuantize, plusTime = 0); var subdivisão = quantizationSplit [1] .trim (); time = Tone. Transport.quantize (toQuantize, subdivisão)} else {var components = time.split (/ [\ (\) \ - \ + \ / \ *] /); if (components.length> 1) {for (var originalTime = tempo i = 0; i <components.length; i ++) {var symb = components [i] .trim (); if (""! == symb) {var val = this.toSeconds (symb); time = time .replace (symb, val)}} tente {time = eval (time)} catch (e) {throw new EvalError ("não pode avaliar Time:" + originalTime)}} else time = this.isNotation (time)? this. NotationToSeconds (time): this.isTransportTime (time)? this.transportTimeToSeconds (time): this.isFrequency (time)? this.frequencyToSeconds (time): this.isTicks (time)? this.ticksToSeconds (time): parseFloat (tempo )} tempo de retorno + plusTime} retornar agora}, Tom.prototype.toNotation = função (t, e, i) {var o = ["1m", "2n", "4n", "8n", "16n", "32n", "64n", "128n"], n = toNotationHelper.call (este, t, e, i, o), r = ["1m", "2n", "2t", "4n", "4t", "8n", "8t", "16n" "," 32t "," 64n "," 64t "," 128n "], s = toNotationHelper.call + "). length <n.split (" + "). length? s: n}, Tone.prototype.fromUnits = function (t, e) {if (! this.convert &&! this.isUndef (this.convert) ) return t; switch (e) {case Tone.Type.Time: retorna this.toSeconds (t); case Tone.Type.Frequency: retorna this.toFrequency (t); case Tone.Type.Decibels: retorna this.dbToGain (t); caso Tone.Type.NormalRange: retorna Math.min (Math.max (t, 0), 1);caso Tone.Type.AudioRange: retorna Math.min (Math.max (t, -1), 1); caso Tone.Type.Positive: return Math.max (t, 0); padrão: return t}}, Tone .prototype.toUnits = function (t, e) {if (! this.convert &&! this.isUndef (this.convert)) retorna t; switch (e) {case Tone.Type.Decibels: retorna this.gainToDb (t) ; padrão: retornar t}}; var noteToScaleIndex = {cbb: -2, cb: -1, c: 0, "c #": 1, cx: 2, dbb: 0, db: 1, d: 2, "d # ": 3, dx: 4, ebb: 2, eb: 3, e: 4," e # ": 5, ex: 6, fbb: 3, fb: 4, f: 5," f # ": 6, fx: 7, gbb: 5, gb: 6, g: 7, "g #": 8, gx: 9, abb: 7, ab: 8, a: 9, "a #": 10, ax: 11, bbb: 9, bb: 10, b: 11, "b #": 12, bx: 13}, scaleIndexToNote = ["C", "C #", "D", "D #", "E", "F", "F #", "G", "G #", "A", "A #", "B"]; retornar Tone.A4 = 440, Tone.prototype.noteToFrequency = function (t) {var e = t.dividir (/ (-? \ d +) /); se (3 === e.length) {var i = noteToScaleIndex [e [0] .toLowerCase ()], o = e [1], n = i + 12 * (parseInt (o, 10) +1); return this.midiToFrequency (n)} return 0}, Tone.prototype.frequencyToNote = função (t) {var e = Math.log (t / Tone.A4) / Matemática .LN2, i = Math.round (12 * e) + 57, o = Math.floor (i / 12); 0> o && (i + = - 12 * o); var n = scaleIndexToNote [i% 12]; retorno n + o.toString ()}, Tone.prototype.intervalToFrequencyRatio = função (t) {return Math.pow (2, t / 12)}, Tone.prototype.midiToNote = função (t) {var e = Math.floor (t / 12) -1, i = t% 12; return scaleIndexToNote [i] + e}, Tone.prototype.noteToMidi = função (t) {var e = t.split (/ (\ d +) /); se (3 === e.length) {var i = noteToScaleIndex [e [0] .toLowerCase ()], o = e [1]; return i + 12 * (parseInt (o, 10) +1)} return 0 }, Tone.prototype.midiToFrequency = função (t) {return Tone.A4 * Math.pow (2, (t-69) / 12)}, Tone} (Tone_core_Tone); var Tone_core_Param; Tone_core_Param = função (t) { "use strict "; return t.Param = function () {var e = this.optionsObject (argumentos, [" param "," unidades "," converter "], t.Param.defaults); this._param = this.input = e.param, this.units = e.unidades, this.convert = e.convert, this.overridden =! 1, this.isUndef (e.value) || (this.value = e.value)}, t .extend (t.Param), t.Param.defaults = {units: t.Type.Default, convert:! 0, param: void 0}, Object.defineProperty (t.Param.prototype, "value", {get : function () {return this._toUnits (this._param.value)}, set: function (t) {var e = this._fromUnits (t); this._param.value = e}}), t.Param. prototype._fromUnits = function (e) {if (! this.convert &&! this.isUndef (this.convert)) retorna e; switch (this.units) {case t.Type.Time: retorna this.toSeconds (e); caso t.Type.Frequency: retorna this.toFrequency (e); case t.Type.Decibels: retorna this.dbToGain (e); case t.Type.NormalRange: return Math.min (Math.max (e, 0), 1); caso t.Type.AudioRange: retorna Math.min (Math.max (e, -1), 1); caso t.Type.Positive: return Math.max (e, 0 ); padrão: retornar e}}, t.Param.prototype._toUnits = function (e) {if (! this.convert &&! this.isUndef (this.convert)) retornar e; switch (this.units) {case t .Type.Decibels: retorna this.gainToDb (e); padrão: return e}}, t.Param.prototype._minOutput = 1e-5, t.Param.prototype.setValueAtTime = função (t, e) {return t = this._fromUnits (t), this._param.setValueAtTime (t, this.toSeconds (e)), this}, t.Param.prototype.setRampPoint = função (t) {t = this.defaultArg (t, this.now (), var e = this._param.value; retorna this._param.setValueAtTime (e, t), this}, t.Param.prototype.linearRampToValueAtTime = função (t, e) {return t = this._fromUnits ( t) this._param.linearRampToValueAtTime (t, this.toSeconds (e)), this}, t.Param.prototype.exponentialRampToValueAtTime = função (t, e) {return t = this._fromUnits (t),t = Math.max (this._minOutput, t), this._param.exponentialRampToValueAtTime (t, this.toSeconds (e)), this}, t.Param.prototype.exponentialRampToValue = function (t, e) {var i = This.now (), o = this.value; return this.setValueAtTime (Math.max (o, this._minOutput), i), this.exponentialRampToValueAtTime (t, i + this.toSeconds (e)),} t.Param.prototype.linearRampToValue = função (t, e) {var i = this.now (); retorna this.setRampPoint (i), this.linearRampToValueAtTime (t, i + this.toSeconds (e)),} , t.Param.prototype.setTargetAtTime = função (t, e, i) {return t = this._fromUnits (t), t = Math.max (this._minOutput, t), i = Math.max (this._minOutput , i), this._param.setTargetAtTime (t, this.toSeconds (e), i), this}, t.Param.prototype.setValueCurveAtTime = function (t, e, i) {for (var o = 0; o <t.length; o ++) t [o] = this._fromUnits (t [o]); retorna this._param.setValueCurveAtTime (t, this.toSeconds (e), this.toSeconds (i)), this}, t .Param.prototype.cancelScheduledValues ​​= function (t) {return this._param.cancelScheduledValues ​​(this.toSeconds (t)), this}, t.Param.prototype.rampTo = function (e, i) {return i = this.defaultArg (i , 0), this.units === t.Type.Frequency || this.units === t.Type.BPM? This.exponentialRampToValue (e, i): this.linearRampToValue (e, i), this}, t.Param.prototype.dispose = function () {return t.prototype.dispose.call (this), this._param = null, this}, t.Param} (Tone_core_Tone); var Tone_core_Gain; Tone_core_Gain = função (t) {"use strict"; return t.Gain = function () {var e = this.optionsObject (argumentos, ["ganho", "unidades"], t.Gain.defaults); this.input = this.output = this ._gainNode = this.context.createGain (), this.gain = new t.Param ({param: this._gainNode.gain, unidades: e.unidades, valor: por exemplo, convert: e.convert}), isto ._readOnly ("ganho")}, t.extend (t.Gain), t.Gain.defaults = {gain: 1, convert:! 0}, t.Gain.prototype.dispose = function () {t.Param.prototype.dispose.call (this), this._gainNode.disconnect (), this._gainNode = null, this._writable ("gain"), this.gain. Elimine (), this.gain = null}, t.Gain} (Tone_core_Tone, Tone_core_Param); var Tone_signal_Signal; Tone_signal_Signal = função (t) {"use strict"; return t.Signal = function () {var e = this. optionsObject (argumentos, ["valor", "unidades"], t.Signal.defaults); this.output = this._gain = this.context.createGain (), e.param = this._gain.gain, t.Param .call (isto, e), this.input = this._param = this._gain.gain, t.Signal._constant.chain (this._gain)}, t.extend (t.Signal, t.Param), t .Signal.defaults = {value: 0, units: t.Type.Default, convert:! 0}, t.Signal.prototype.connect = t.SignalBase.prototype.connect, t.Signal.prototype.dispose = function ( ) {return t.Param.prototype.dispose.call (this), this._param = null, this._gain.desconecte (), this._gain = null, this}, t.Signal._constant = null, t._initAudioContext (function (e) {for (var i = e.createBuffer (1.128, e.sampleRate), o = i. getChannelData (0), n = 0; n <o.length; n ++) o [n] = 1; t.Signal._constant = e.createBufferSource (), t.Signal._constant.channelCount = 1, t.Signal. _constant.channelCountMode = "explicit", t.Signal._constant.buffer = i, t.Signal._constant.loop =! 0, t.Signal._constant.start (0), t.Signal._constant.noGC ()} ), t.Signal} (Tone_core_Tone, Tone_signal_WaveShaper, Tone_core_Type, Tone_core_Param); var Tone_signal_Add; Tone_signal_Add = função (t) {"use strict"; retornar t.Add = function (e) {t.call (this, 2,0 ), this._sum = this.input [0] = this.input [1] = this.output = this.context.createGain (), this._param = this.input [1] = new t.Signal (e) , this._param.connect (this._sum)}, t.extend (t.Add, t.Signal), t.Add.prototype.dispose = function () {return t.prototype.disponha.call (this), this._sum.disconnect (), this._sum = null, this._param.dispose (), this._param = null, this}, t.Add} (Tone_core_Tone); var Tone_signal_Multiply; Tone_signal_Multiply = função (t) {"use strict"; retornar t.Multiply = function (e) {t.call (this, 2,0), this._mult = this.input [0] = this.output = this.context .createGain (), this._param = this.input [1] = this.output.gain, this._param.value = this.defaultArg (e, 0)}, t.extend (t.Multiply, t.Signal) , t.Multiply.prototype.dispose = function () {return t.prototype.dispose.call (this), this._mult.disconnect (), this._mult = null, this._param = null, this}, t. Multiplique} (Tone_core_Tone); var Tone_signal_Scale; Tone_signal_Scale = função (t) {"use strict"; return t.Scale = function (e, i) {this._outputMin = this.defaultArg (e, 0), this._outputMax = this.defaultArg (i, 1), this._scale = this.input = new t.Multiply (1), this._add = this.output = new t.Add (0), isto._scale.connect (this._add), this._setRange ()}, t.extend (t.Scale, t.SignalBase), Object.defineProperty (t.Scale.prototype, "min", {get: function () { retornar this._outputMin}, definir: function (t) {this._outputMin = t, this._setRange ()}}), Object.defineProperty (t.Scale.prototype, "max", {get: function () {return this._outputMax}, set: function (t) {this._outputMax = t, this._setRange ()}}), t.Scale.prototype._setRange = function () {this._add.value = this._outputMin, this ._scale.value = this._outputMax-this._outputMin}, t.Scale.prototype.dispose = function () {return t.prototype.dispose.call (this), this._add.dispose (), this._add = null this._scale.dispose (), this._scale = null, this}, t.Scale} (Tone_core_Tone, Tone_signal_Add, Tone_signal_Multiply); var sign; signal = function () {"use strict"; var t = Tone_signal_Signal, e = Tone_signal_Add, i = Tone_signal_Multiply, o = Tone_signal_Scale,n = Tone_core_Tone, r = master; n.setContext (r.audiocontext), p5.Signal = função (e) {var i = new t (e); return i}, t.prototype.fade = t.prototype.linearRampToValueAtTime , i.prototype.fade = t.prototype.fade, e.prototype.fade = t.prototype.fade, o.prototype.fade = t.prototype.fade, t.prototype.setInput = function (t) {t. connect (this)}, i.prototype.setInput = t.prototype.setInput, e.prototype.setInput = t.prototype.setInput, o.prototype.setInput = t.prototype.setInput, t.prototype.add = function ( t) {var i = new e (t); retorna this.connect (i), i}, i.prototype.add = t.prototype.add, e.prototype.add = t.prototype.add, o.prototype .add = t.prototype.add, t.prototype.mult = function (t) {var e = new i (t); retorna this.connect (e), e}, i.prototype.mult = t.prototype. mult, e.prototype.mult = t.prototype.mult, o.prototype.mult = t.prototype.mult, t.prototype.scale = função (t, e, i, n) {var r, s; 4 = == argumentos.length? (r = p5.prototype.map (i, t,e, 0,1) - .5, s = p5.prototype.map (n, t, e, 0,1) -. 5) :( r = argumentos [0], s = argumentos [1]); var a = novo o (r, s); retorna this.connect (a), a}, i.prototype.scale = t.prototype.scale, e.prototype.scale = t.prototype.scale, o.prototype.scale = t.prototype.scale} (Tone_signal_Signal, Tone_signal_Add, Tone_signal_Multiply, Tone_signal_Scale, Tone_core_Tone, master); var oscilador; oscillator = function () {"use strict"; var t = master, e = Tone_signal_Add, i = Tone_signal_Multiply, o = Tone_signal_Scale; p5.Oscillator = função (e, i) {if ("string" == typeof e) {var o = i; i = e, e = o} if ("number" == typeof i) {var o = i; i = e, e = o} this.started =! 1, this.phaseAmount = void 0, this.oscillator = t.audiocontext.createOscillator (), this.f = e || 440, this.oscillator. type = i || "sine", this.oscillator.frequency.setValueAtTime (this.f, t.audiocontext.currentTime); this.oscillator; this.output = t.audiocontext.createGain (), this._freqMods = [], this.output.gain.value = .5, this.output.gain.setValueAtTime (.5, t.audiocontext.currentTime), this.oscillator.connect (this.output) , this.panPosition = 0, this.connection = t.input, this.panner = new p5.Panner (this.output, this.connection, 1), this.mathOps = [this.output], t.soundArray.push (isto)}, p5.Oscillator.prototype.start = função (e, i) {if (this.started) {var o = t.audiocontext.currentTime; this.stop (o)} se (! this.started) {var n = i || this.f, r = this.oscillator.type; this.oscillator && (this.oscillator.disconnect (), this.oscillator = void 0), this.oscillator = t.audiocontext.createOscillator () , this.oscillator.frequency.exponentialRampToValueAtTime (Math.abs (n), t.audiocontext.currentTime), this.oscillator.type = r, this.oscillator.connect (this.output), e = e || 0, this .oscillator.start (e + t.audiocontext.currentTime), this.freqNode = this.oscillator.frequency;para (var s neste._freqMods) "indefinido"! = typeof this._freqMods [s] .connect && this._freqMods [s] .connect (this.oscillator.frequency); this.started =! 0}}, p5.Oscilador .prototype.stop = function (e) {if (this.started) {var i = e || 0, o = t.audiocontext.currentTime; this.oscillator.stop (i + o), this.started =! 1 }}, p5.Oscillator.prototype.amp = function (e, i, o) {var n = this; if ("number" == typeof e) {var i = i || 0, o = o || 0 , r = t.audiocontext.currentTime, s = this.output.gain.value; this.output.gain.cancelScheduledValues ​​(r), this.output.gain.linearRampToValueAtTime (s, r + o), this.output.gain .linearRampToValueAtTime (e, r + o + i)} else {if (! e) retorna this.output.gain; e.connect (n.output.gain)}}, p5.Oscillator.prototype.fade = p5.Oscillator .prototype.amp, p5.Oscillator.prototype.getAmp = function () {return this.output.gain.value}, p5.Oscillator.prototype.freq = function (e, i, o) {if ("número "! = typeof e || isNaN (e)) {if (! e) retorna this.oscillator.frequency; e.output && (e = e.output), e.connect (this.oscillator.frequency), isto. _freqMods.push (e)} else {this.f = e; var n = t.audiocontext.currentTime, i = i || 0, o = o || 0; 0 == i? (this.oscillator.frequency. cancelScheduledValues ​​(n), this.oscillator.frequency.setValueAtTime (e, o + n)): e> 0? this.oscillator.frequency.exponentialRampToValueAtTime (e, o + i + n): this.oscillator.frequency.linearRampToValueAtTime ( e, o + i + n), this.phaseAmount && this.phase (this.phaseAmount)}}, p5.Oscillator.prototype.getFreq = function () {return this.oscillator.frequency.value}, p5.Oscillator.prototype. setType = função (t) {this.oscillator.type = t}, p5.Oscillator.prototype.getType = function () {return this.oscillator.type}, p5.Oscillator.prototype.connect = function (e) {e ? e.hasOwnProperty ("input")? (this.panner.connect (e.input), isto.connection = e.input) :( this.panner.connect (e), this.connection = e): this.panner.connect (t.input)}, p5.Oscillator.prototype.disconnect = function (t) {this .output.disconnect (), this.panner.disconnect (), this.output.connect (this.panner), this.oscMods = []}, p5.Oscillator.prototype.pan = function (t, e) {this .panPosition = t, this.panner.pan (t, e)}, p5.Oscillator.prototype.getPan = function () {return this.panPosition}, p5.Oscillator.prototype.dispose = function () {var e = t.soundArray.indexOf (this); if (t.soundArray.splice (e, 1), this.oscillator) {var i = t.audiocontext.currentTime; this.stop (i), this.disconnect (), this .panner = null, this.oscillator = null} this.osc2 && this.osc2.dispose ()}, p5.Oscillator.prototype.phase = função (e) {var i = p5.prototype.map (e, 0,1, 0,1 / this.f), o = t.audiocontext.currentTime; this.phaseAmount = e, this.dNode || (this.dNode = t.audiocontext.createDelay (), this.oscillator.desconecte (), this.oscillator.connect (this.dNode), this.dNode.connect (this.output)), this.dNode.delayTime.setValueAtTime (i, o)}; var n = function (t, e, i, o, n) {var r = t.oscillator; para (var s in t.mathOps) t.mathOps [s] instanceof n && (r.disconnect (), t.mathOps [s] .dispose (), i = s, i <t.mathOps.length-2 && (o = t.mathOps [s + 1])); return i == t.mathOps.length-1 && t.mathOps.push (o), s> 0 && (r = t.mathOps [s-1]), r.disconnect (), r.connect (e), e.connect (o), t.mathOps [i] = e, t}; p5.Oscillator.prototype.add = função (t) {var i = new e (t), o = this.mathOps.length-1, r = this.output; return n (this, i, o, r, e)}, p5.Oscilador. prototype.mult = function (t) {var e = new i (t), o = this.mathOps.length-1, r = this.output; return n (this, e, o, r, i)}, p5 .Oscillator.prototype.scale = function (t, e, i, r) {var s, a; 4 === arguments.length? (S = p5.prototype.map (i, t, e, 0,1) -.5, a = p5.prototype.map (r, t, e, 0,1) -. 5):(s = argumentos [0], a = argumentos [1]); var u = novo o (s, a), p = this.mathOps.length-1, c = this.output; return n (this, u, p, c, o)}, p5.SinOsc = função (t) {p5.Oscillator.call (this, t, "sine")}, p5.SinOsc.prototype = Object.create (p5.Oscillator.prototype), p5.TriOsc = função (t) {p5.Oscillator.call (este, t, "triângulo")}, p5.TriOsc.prototype = Object.create (p5.Oscillator.prototype), p5.SawOsc = function (t) {p5.Oscilator.call (this, t, "sawtooth")}, p5.SawOsc.prototype = Object.create (p5.Oscillator.prototype), p5.SqrOsc = function (t) {p5.Oscillator.call (isto , t, "square")}, p5.SqrOsc.prototype = Object.create (p5.Oscillator.prototype)} (mestre, Tone_signal_Signal, Tone_signal_Add, Tone_signal_Multiply, Tone_signal_Scale); var Tone_core_Timeline; Tone_core_Timeline = função (t) {"usar estrito "; retornar t.Timeline = function () {var e = this.optionsObject (argumentos, ["memória "], t.Timeline.defaults); this._timeline = [], this._toRemove = [], this._iterating =! 1, this.memory = e.memory}, t.extend (t.Timeline), t.Timeline.defaults = {memory: 1/0}, Object.defineProperty (t.Timeline.prototype, "length", {get: function () {return this._timeline.length}}), t.Timeline.prototype .addEvent = função (t) {if (this.isUndef (t.time)) lança novo erro ("eventos devem ter um atributo de tempo"), se (t.time = this.toSeconds (t.time), isto. _timeline.length) {var e = this._search (t.time); this._timeline.splice (e + 1,0, t)} else this._timeline.push (t); se (this.length> this. memória) {var i = this.length-this.memory; this._timeline.splice (0, i)} retorna isso}, t.Timeline.prototype.removeEvent = function (t) {if (this._iterating) this. _toRemove.push (t); else {var e = this._timeline.indexOf (t); - 1! == e && this._timeline.splice (e, 1)} retorna isso}, t.Timeline.prototype.getEvent = function (t) {t = this.toSeconds (t); var e = this._search (t); return-1! == e? this._timeline [e]: null}, t.Timeline.prototype. getEventAfter = função (t) {t = this.toSeconds (t); var e = this._search (t); retornar e + 1 <this._timeline.length? this._timeline [e + 1]: null}, t .Timeline.prototype.getEventBefore = function (t) {t = this.toSeconds (t); var e = this._search (t); return e-1> = 0? This._timeline [e-1]: null} , t.Timeline.prototype.cancel = function (t) {if (this._timeline.length> 1) {t = this.toSeconds (t); var e = this._search (t); e> = 0? this ._timeline = this._timeline.slice (0, e): this._timeline = []} else 1 === this._timeline.length && this._timeline [0] .time> = t && (this._timeline = []); devolva isto}, t.Timeline.prototype.cancelBefore = function (t) {if (this._timeline.length) {t = this.toSeconds (t); var e = this._search (t); e> = 0 && ( this._timeline = this._timeline.slice (e + 1))} return this}, t.Timeline.prototype._search = function (t) {for (var e = 0, i = this._timeline.length, o = i; o> = e && i> e ;) {var n = Math.floor (e + (oe) / 2), r = this._timeline [n]; if (r.time === t) {for (var s = n; s <this._timeline .length; s ++) {var a = this._timeline [s]; a.time === t && (n = s)} return n} r.time> t? o = n-1: r.time <t && ( e = n + 1)} return e-1}, t.Timeline.prototype._iterate = função (t, e, i) {this._iterating =! 0, e = this.defaultArg (e, 0), i = this.defaultArg (i, this._timeline.length-1); para (var o = e; i> = o; o ++) t (this._timeline [o]); se (this._iterating =! 1, this. _toRemove.length> 0) {for (var n = 0; n <this._toRemove.length; n ++) {var r = this._timeline.indexOf (this._toRemove [n]); - 1! == r && this._timeline .splice (r, 1)} this._toRemove = []}}, t.Timeline.prototype.forEach = function (t) {return this._iterate (t), this}, t.Timeline.prototype.forEachBefore = function (t,e) {t = this.toSeconds (t); var i = this._search (t); return-1! == i && this._iterate (e, 0, i), this}, t.Timeline.prototype.forEachAfter = função (t, e) {t = this.toSeconds (t); var i = this._search (t); retorna this._iterate (e, i + 1), this}, t.Timeline.prototype.forEachFrom = function (t, e) {t = this.toSeconds (t); for (var i = this._search (t); i> = 0 && this._timeline [i] .time> = t;) i -; retorna isso. _iterate (e, i + 1), this}, t.Timeline.prototype.forEachAtTime = função (t, e) {t = this.toSeconds (t); var i = this._search (t); return-1! == i && this._iterate (função (i) {i.time === t && e (i)}, 0, i), isto}, t.Timeline.prototype.dispose = function () {t.prototype.dispose.call (isto), this._timeline = null, this._toRemove = null}, t.Timeline} (Tone_core_Tone); var Tone_signal_TimelineSignal; Tone_signal_TimelineSignal = função (t) {"use strict"; retornar t.TimelineSignal = function () {var e = isto.optionsObject (argumentos, ["valor", "unidades"], t.Signal.defaults); t.Signal.apply (this, e), e.param = this._param, t.Param.call (isto, e) , this._events = new t.Timeline (10), this._initial = this._fromUnits (this._param.value)}, t.extend (t.TimelineSignal, t.Param), t.TimelineSignal.Type = {Linear : "linear", Exponencial: "exponencial", Alvo: "alvo", Definir: "conjunto"}, Object.defineProperty (t.TimelineSignal.prototype, "valor", {get: function () {return this._toUnits ( this._param.value)}, set: function (t) {var e = this._fromUnits (t); this._initial = e, this._param.value = e}}), t.TimelineSignal.prototype.setValueAtTime = função (e, i) {return e = this._fromUnits (e), i = this.toSeconds (i), this._events.addEvent ({type: t.TimelineSignal.Type.Set, value: e, time: i }), this._param.setValueAtTime (e, i), isto}, t.TimelineSignal.prototype.linearRampToValueAtTime = função (e, i) {return e = this._fromUnits (e),
Não houve resposta do servidor em "+ n.url +". Verifique a url e a conectividade com a Internet. "; O? (I.message = s, o (i)): console.error (s +" \ n O rastreamento da pilha de erros inclui: \ n "+ i.stack)}, a. Enviar ()}, p5.Convolver.prototype.set = null, p5.Convolver.prototype.process = function (t) {t.connect (this.input)}, p5.Convolver.prototype.impulses = [], p5 .Convolver.prototype.addImpulse = função (t, e, i) {window.location.origin.indexOf ("file: //")> - 1 && "undefined" === window.cordova && alert ("Este esboço pode exigir uma servidor para carregar arquivos externos. Por favor, veja http://bit.ly/1qcInwS"), this._loadBuffer(t,e,i)},p5.Convolver.prototype.resetImpulse=function(t,e,i){window .location.origin.indexOf ("file: //")> - 1 && "undefined" === window.cordova && alert (" Este esboço pode exigir que um servidor carregue arquivos externos. Por favor, veja http://bit.ly/1qcInwS"), thisis.impulses=[], this._loadBuffer(t,e,i)},p5.Convolver.prototype.toggleImpulse=function(t){if("number "== typeof t && t <this.impulses.length && (this.convolverNode.buffer = this.impulses [t] .audioBuffer)," string "== typeof t) para (var e = 0; e <this.impulses.length ; e ++) se (this.impulses [e] .name === t) {this.convolverNode.buffer = this.impulses [e] .audioBuffer; break}}, p5.Convolver.prototype.dispose = function () { para (var t neste.impulsos) this.impulses [t] = null; this.convolverNode.disconnect (), this.concolverNode = null, "indefinido"! = typeof this.output && (this.output.disconnect (), this.output = null), "indefinido"! = typeof this.panner && (this.panner.disconnect (), this.panner = null)}} (master, errorHandler, sndcore);
cancelAnimationFrame (this._loopID), t.TimelineState.prototype.dispose.call (this), this._writable ("frequency"), this.frequency.dispose (), this.frequency = null, this._boundLoop = t.noOp , this._nextTick = 1/0, this.callback = null, this._state.dispose (), this._state = null}, t.Clock} (Tone_core_Tone, Tone_signal_TimelineSignal); var metro; metro = function () {" use strict "; var t = master, e = Tone_core_Clock; t.audiocontext; p5.Metro = function () {this.clock = new e ({callback: this.ontick.bind (this)}), this.syncedParts = [], this.bpm = 120, this._init (), this.tickCallback = function () {}}; var i = 0, o = 0; p5.Metro.prototype.ontick = function (e) {var n = ei, r = et.audiocontext.currentTime; if (! (-. 02> = no)) {i = e; for (var s neste.syncedParts) {var a = this.syncedParts [s]; se ( !. a.isPlaying) return; a.incrementStep (r); para (var u in a.phrases) {var p = a.phrases [u], c = p.sequence, h = this.metroTicks% c.length;0! == c [h] && (this.metroTicks <c.length ||! P.looping) && p.callback (r, c [h])}} this.metroTicks + = 1, this.tickCallback (r)} } p5.Metro.prototype.setBPM = função (e, i) {var n = 60 / (e * this.tatums), r = t.audiocontext.currentTime; o = n; var i = i || 0; this.clock.frequency.setValueAtTime (this.clock.frequency.value, r), this.clock.frequency.linearRampToValueAtTime (e, r + i), this.bpm = e}, p5.Metro.prototype.getBPM = função (t) {return this.clock.getRate () / this.tatums * 60}, p5.Metro.prototype._init = function () {this.metroTicks = 0}, p5.Metro.prototype.resetSync = função (t ) {this.syncedParts = [t]}, p5.Metro.prototype.pushSync = função (t) {this.syncedParts.push (t)}, p5.Metro.prototype.start = função (e) {var i = e || 0, o = t.audiocontext.currentTime; this.clock.start (o + i), this.setBPM (this.bpm)}, p5.Metro.prototype.stop = function (e) {var i = e || 0, o = t.audiocontext.currentTime; this.clock._oscillator && this.clock.stop (o + i)}, p5.Metro.prototype.beatLength = função (t) {this.tatums = 1 / t / 4}} (mestre, Tone_core_Clock); var looper; looper = function () {"use strict"; função t (t) {t.currentPart ++, t.currentPart> = t.parts.length? (t.scoreStep = 0, t.onended ()) :( t.scoreStep = 0, t. partes [t.currentPart-1] .stop (), t.parts [t.currentPart] .start ())} var e = master, i = 120; p5.prototype.setBPM = função (t, o) {i = t; for (var n in e.parts) e.parts [n] .setBPM (i, o)}, p5.Phrase = função (t, e, i) {this.phraseStep = 0, this.name = t, this.callback = e, this.sequence = i}, p5.Part = function (t, o) {this.length = t || 0, this.partStep = 0, this.phrases = [], isto. isPlaying =! 1, this.noLoop (), this.tatums = o || .0625, this.metro = new p5.Metro, this.metro._init (), this.metro.beatLength (this.tatums), isto .metro.setBPM (i), e.parts.push (this), this.callback = function () {}}, p5.Part.prototype.setBPM = function (t, e) {this.metro.setBPM (t, e)}, p5.Part.prototype.getBPM = function () {return this.metro.getBPM ()}, p5.Part.prototype.start = função (t) {if (! this. isPlaying) {this.isPlaying =! 0, this.metro.resetSync (this); var e = t || 0; this.metro.start (e)}}, p5.Part.prototype.loop = função (t) {this.looping =! 0, this.onended = function () {this.partStep = 0}; var e = t || 0; this.start (e)}, p5.Part.prototype.noLoop = function () {this.looping =! 1, this.onended = function () {this.stop ()}}, p5.Part.prototype.stop = function (t) {this.partStep = 0, this.pause (t)} , p5.Part.prototype.pause = function (t) {this.isPlaying =! 1; var e = t || 0; this.metro.stop (e)}, p5.Part.prototype.addPhrase = função (t e, i) {var o; if (3 === arguments.length) o = new p5.Phrase (t, e, i); else {if (! (argumentos [0] instanceof p5.Phrase)) throw "entrada inválida. addPhrase aceita nome, retorno de chamada, matriz ou p5.Phrase"; o = argumentos [0]} this.phrases.push (o), o.sequence.length> this.length && (this.length = o.sequence.length)}, p5.Part.prototype.removePhrase = function (t) {for (var e neste this.phrases) this.phrases [e] .name == = t && this.phrases.splice (e, 1)}, p5.Part.prototype.getPhrase = function (t) {for (var e nesta frase) se (this.phrases [e] .name === t) devolva this.phrases [e]}, p5.Part.prototype.replaceSequence = function (t, e) {for (var i in this.phrases) this.phrases [i] .name === t && (this.phrases [ i] .sequence = e)}, p5.Part.prototype.incrementStep = function (t) {this.partStep <this.length-1? (this.callback (t), this.partStep + = 1): this.looping || this.partStep! = this.length-1 || (console.log ("done"), this.onended ())}, p5.Part.prototype.onStep = function (t) {this.callback = t } p5.Score = function () {this.parts = [], this.currentPart = 0; var e = this; for (var i in arguments) this.parts [i] = argumentos [i], this.parts [i] .nextPart = this.parts [i + 1],this.parts [i] .onended = function () {e.resetPart (i), t (e)}; this.looping =! 1}, p5.Score.prototype.onended = function () {this.looping? this.parts [0] .start (): this.parts [this.parts.length-1] .onended = function () {this.stop (), this.resetParts ()}, this.currentPart = 0}, p5.Score.prototype.start = function () {this.parts [this.currentPart] .start (), this.scoreStep = 0}, p5.Score.prototype.stop = function () {this.parts [this. currentPart] .stop (), this.currentPart = 0, this.scoreStep = 0}, p5.Score.prototype.pause = function () {this.parts [this.currentPart] .stop ()}, p5.Score. prototype.loop = function () {this.looping =! 0, this.start ()}, p5.Score.prototype.noLoop = function () {this.looping =! 1}, p5.Score.prototype.resetParts = function () {for (var t in this.parts) this.resetPart (t)}, p5.Score.prototype.resetPart = função (t) {this.parts [t] .stop (), this.parts [t ] .partStep = 0; for (var e neste.partes [t] .phrases) this.parts [t].frases [e] .phraseStep = 0}, p5.Score.prototype.setBPM = função (t, e) {para (var i neste.partes) this.parts [i] .setBPM (t, e)}} ( mestre); var soundRecorder; soundRecorder = function () {"use strict"; função t (t, e) {for (var i = t.length + e.length, o = new Float32Array (i), n = 0, r = 0; i> r;) o [r ++] = t [n], o [r ++] = e [n], n ++; return o} função e (t, e, i) {for (var o = i .length, n = 0; o> n; n ++) t.setUint8 (e + n, i.charCodeAt (n))} var i = master, o = i.audiocontext; p5.SoundRecorder = function () {this. input = o.createGain (), this.output = o.createGain (), this.recording =! 1, this.bufferSize = 1024, this._channels = 2, this._clear (), this._jsNode = o.createScriptProcessor (this._buffferSize, this._channels, 2), this._jsNode.onaudioprocess = this._audioprocess.bind (this), this._callback = function () {}, this._jsNode.connect (p5.soundOut._silentNode), this.setInput (), i.soundArray.push (this)}, p5.SoundRecorder.prototype.setInput = function (t) {this.input.disconnect (), this.input = null, this.input = o.createGain (), this.input.connect (this._jsNode), this.input.connect (this. saída), t? t.connect (this.input): p5.soundOut.output.connect (this.input)}, p5.SoundRecorder.prototype.record = function (t, e, i) {this.recording =! 0, e && (this.sampleLimit = Math.round (e * o.sampleRate)), t && i? This._callback = function () {this.buffer = this._getBuffer (), t.setBuffer (this.buffer), i (): t && (this._callback = function () {this.buffer = this._getBuffer (), t.setBuffer (this.buffer)})}, p5.SoundRecorder.prototype.stop = function () {this. gravação =! 1, this._callback (), this._clear ()}, p5.SoundRecorder.prototype._clear = function () {this._leftBuffers = [], this._rightBuffers = [], this.recordedSamples = 0, this.sampleLimit = null}, p5.SoundRecorder.prototype._audioprocess = function (t) {if (this.recording! ==! 1 && this.gravando ===! 0) se (this.sampleLimit && this.recordedSamples> = this.sampleLimit) this.stop (); else {var e = t.inputBuffer.getChannelData (0), i = t.inputBuffer.getChannelData (1) ; this._leftBuffers.push (novo Float32Array (e)), this._rightBuffers.push (novo Float32Array (i)), this.recordedSamples + = this.bufferSize}}, p5.SoundRecorder.prototype._getBuffer = function () {var t = []; return t.push (this._mergeBuffers (this._leftBuffers)), t.push (this._mergeBuffers (this._rightBuffers)), t}, p5.SoundRecorder.prototype._mergeBuffers = function (t) { para (var e = novo Float32Array (this.recordedSamples), i = 0, o = t.length, n = 0; o> n; n ++) {var r = t [n]; e.set (r, i) , i + = r.length} return e}, p5.SoundRecorder.prototype.dispose = function () {this._clear (); var t = i.soundArray.indexOf (this); i.soundArray.splice (t, 1 ), this._callback = function () {}, this.input && this.input.disconnect (), this.input = null, this._jsNode = null}, p5.prototype.saveSound = função (i, o) {var n, r; n = i.buffer.getChannelData (0), r = i.buffer.numberOfChannels> 1? i.buffer.getChannelData ( 1): n; var s = t (n, r), a = novo ArrayBuffer (44 + 2 * s.length), u = novo DataView (a); e (u, 0, "RIFF"), u. setUint32 (4,36 + 2 * s.length,! 0), e (u, 8, "WAVE"), e (u, 12, "fmt"), u.setUint32 (16,16,! 0), u.setUint16 (20,1,! 0), u.setUint16 (22,2,! 0), u.setUint32 (24,44100,! 0), u.setUint32 (28,176400,! 0), u. setUint16 (32,4,! 0), u.setUint16 (34,16,! 0), e (u, 36, "dados"), u.setUint32 (40,2 * s.length,! 0); para (var p = s.length, c = 44, h = 1, l = 0; p> l; l ++) u.setInt16 (c, s [l] * (32767 * h) ,! 0), c + = 2 ; p5.prototype.writeFile ([u], o, "wav")}} (sndcore, master); var peakdetect; peakdetect = function () {"use strict"; p5.PeakDetect = function (t, e, i , o) {this.framesPerPeak = o || 20, this.framesSinceLastPeak = 0, this.decayRate = .95, this.threshold = i ||.35, this.cutoff = 0, this.cutoffMult = 1.5, this.energy = 0, this.penergy = 0, this.currentValue = 0, this.isDetected =! 1, this.f1 = t || 40, isto. f2 = e || 2e4, this._onPeak = function () {}}, p5.PeakDetect.prototype.update = função (t) {var e = this.energy = t.getEnergy (this.f1, this.f2) /255;e>this.cutoff&&e>this.threshold&ðth.f (this.framesSinceLastPeak <= this.framesPerPeak? this.framesSinceLastPeak ++ :( this.cutoff * = this.decayRate, this.cutoff = Math.max (this.cutoff, this.threshold))), this.currentValue = e, this.penergy = e}, p5.PeakDetect.prototype.onPeak = função (t, e) {var i = this; i._onPeak = function () {t (i.energy, e)} }} (mestre); var gain; gain = function () {"use strict"; var t = master; p5.Gain = function () {this.ac = t.audiocontext, this.input = this.ac.createGain (), this.output = this.ac.createGain (), this.input.gain.value = .5, this.input.connect (this.output), t.soundArray.push (this)}, p5. Gain.prototype.setInput = function (t) {t.connect (this.input)}, p5.Gain.prototype.connect = function (t) {var e = t || p5.soundOut.input; this.output. connect (e.input? e.input: e)}, p5.Gain.prototype.disconnect = function () {this.output.disconnect ()}, p5.Gain.prototype.amp = function (e, i, o ) {var i = i || 0, o = o || 0, n = t.audiocontext.currentTime, r = this.output.gain.value; this.output.gain.cancelScheduledValues ​​(n), this.output. ganho.linearRampToValueAtTime (r, n + o), this.output.gain.linearRampToValueAtTime (e, n + o + i)}, p5.Gain.prototype.dispose = function () {var e = t.soundArray.indexOf ( isto); t.soundArray.splice (e, 1), this.output.disconnect (), this.input.disconnect (), this.output = void 0, this.input = void 0}} (master, sndcore) ; distorção de var; distorção = função () {"use strict "; função t (t) {para (var e, i =" number "== typeof t? t: 50, o = 44100, n = novo Float32Array (o), r = Math.PI / 180, s = 0; o> s; ++ s) e = 2 * s / o-1, n [s] = (3 + i) * e * 20 * r / (Math.PI + i * Math.abs (e )); return n} var e = master; p5.Distortion = função (i, o) {if ("indefinido" == typeof i && (i = .25), "number"! = typeof i) throw new Error ( "quantidade deve ser um número"); se ("indefinido" == tipo de o && (o = "2x"), "string"! = typeof o) lançar novo erro ("oversample deve ser uma String"); var n = p5.prototype.map (i, 0,1,0,2e3); this.ac = e.audiocontext, this.input = this.ac.createGain (), this.output = this.ac.createGain (), isto .waveShaperNode = this.ac.createWaveShaper (), this.amount = n, this.waveShaperNode.curve = t (n), this.waveShaperNode.oversample = o, this.input.connect (this.waveShaperNode), this.waveShaperNode .connect (this.output), isto.connect (), e.soundArray.push (this)}, p5.Distortion.prototype.process = function (t, e, i) {t.connect (this.input), this.set (e, i)}, p5.Distortion.prototype.set = function (e, i) {if (e) {var o = p5.prototype.map (e, 0,1,0,2e3); this.amount = o, this.waveShaperNode. curva = t (o)} i && (this.waveShaperNode.oversample = i)}, p5.Distortion.prototype.getAmount = function () {return this.amount}, p5.Distortion.prototype.getOversample = function () {return this.waveShaperNode.oversample}, p5.Distortion.prototype.connect = function (t) {var e = t || p5.soundOut.input; this.output.connect (e)}, p5.Distortion.prototype.disconnect = function () {this.output.disconnect ()}, p5.Distortion.prototype.dispose = function () {var t = e.soundArray.indexOf (this); e.soundArray.splice (t, 1), isto. input.disconnect (), this.waveShaperNode.disconnect (), this.input = null, this.waveShaperNode = null, "indefinido"! = typeof this.saída && (this.output.disconnect (), this.output = null)}} (mestre); var src_app; src_app = function () {"use strict"; var t = sndcore; return t} (sndcore, master, helpers , errorHandler, panner, soundfile, amplitude, fft, sinal, oscilador, env, pulso, ruído, áudio, filtro, atraso, reverb, metro, looper, soundRecorder, peakdetect, gain, distortion)});
